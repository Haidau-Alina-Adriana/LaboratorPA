1. Compulsory: 
Am creat interfetele Identifiable si Storage, care contin cate o metoda: getAddress(), respectiv getStorageCapacity. Am creat clasa Network ce contine o lista de noduri din retea, clasa Node ce modeleaza un nod din retea (fiecare nod are un nume, o adresa MAC si o locatie) si clasele Computer, Router si Switch ce mostenesc clasa Node si implementeaza interfetele create. Pentru fiecare am creat settere, gettere, constructori si metoda toString() si am implementat metodele din interfetele corespunzatoare. Clasa Node implementeaza interfata Comparable care ne permite sa ordonam obiectele de tip Node cu ajutorul functiei compareTo() in functie de numele nodurilor. In main am creat nodurile din exemplu.

2. Homework:
In clasa Node am adaugat un atribut ce va reprezenta costurile pentru fiecare nod. Am adaugat o functie compareByHardwareAddress care va compara 2 noduri din retea prin adresa lor hardware. In interfata Storage am adaugat 3 metode default ce vor returna numarul dat ca parametru ca un BigInteger (in cazul in care capacitatea de stocare este mare) valoarea capacitatii in mg, kb si bytes. In clasa Network am creat o metoda care va afisa exemplul, si o metoda care verifica si afiseaza nodurile care sunt instante de tip Identifible, dupa care le sorteaza folosind metoda compareByHardwareAddress din clasa Node.
Am creat o clasa Algorithm ce contine un map times in care salvez nodul si timpul cel mai scurt de la nod la nodul din care pronesc algoritmul. 
Am un constructor in care initializez map-ul astfel: pentru nodul de start pun 0, iar pentru celelalte pun o valoare foarte mare. Am creat un setter si metoda toString si metoda getShortestTimes. In aceasta metoda caut de fiecare data cea mai mica valoare a timpului din map si actualizez nodul de la care reincep actualizarea timpurilor, iar apoi parcurg toti vecinii acestui nod si verific daca noul timp este mai mic decat cel curent si il actualizez. Apoi adaug nodul curent la cele deja vizitate. Insa aceasta metoda nu tine cont daca un nod este sau nu Identifiable.
