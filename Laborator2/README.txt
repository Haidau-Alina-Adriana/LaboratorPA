1. Compulsory:
Am creat o clasa cu numele Room ce contine 3 atribute: nume, capacitate si tip (tipul camerei este de tip RoomType, modelat ca un enum cu valorile posibile LECTURE_HALL si COMPUTER_LAB). Clasa contine si un constructor care va initializa toate atributele clasei, dar si unul default. De asemenea, pentru fiecare atribut am creat un setter si un getter, care va actualiza atributul, respectiv va returna valoarea curenta a atributului. Metoda toString() o va suprascrie pe cea a clasei Object pentru a afisa informatiile fiecarui obiect de tip Room.

Pentru clasa Event este asemenator, ea are ca atribute nume, size, start si end. Ca metode am creat setterele, getterele si cei doi constructori, dar si metoda toString ce o va suprascrie pe cea a clasei Object pentru a returna informatiile fiecarui obiect de tip Event. 
In main am creat obiectele din exemplu si le-am afisat folosind metoda toString.

2. Homework:
Fata de compulsory am suprascris metoda equals atat pentru clasa Room, cat si pentru clasa Event, care va verifica daca 2 camere, respectiv 2 evenimente au acelasi nume (de exemplu 2 evenimente pot sa aiba acelasi numar de participanti si pot sa fie in acelasi interval orar, deci singurul mod de deosebire intre cele 2 este prin nume). Clasa Room devine clasa abstracta,  urmand ca cele doua valori disponibile din enum sa devina clase ce vor mosteni clasa Room. Clasa ComputerLab mosteneste clasa Room si contine un atribut hasProjector de tip boolean ce va modela daca o camera are proiector, iar clasa LectureHall mosteneste clasa Room si are un atribut operatingSystem de tip String ce reprezinta sistemul de operare al calculatoarelor din laborator. De asemenea am creat settere si gettere pentru aceste atribute.
Clasa Problem contine 2 array-uri, unul cu obiecte de tip Event si unul cu obiecte de tip Room. Am creat 2 constructori, settere, gettere, metoda toString si 2 metode care modeleaza adaugarea unui eveniment sau a unei camere: parcurgem array-ul de evenimente/camere si verificam folosind functia equals sa vedem daca gasim un eveniment/camera cu acelasi nume (caz in care functia nu va adauga in array obiectul respectiv). De asemenea, contine si o metoda care afiseaza toate evenimentele si salile, cat si valorile atributelor. 

Clasa Solution contine ca atribut un arraylist cu String-uri cu repartizarea fiecarui eveniment la o camera, un getter pentru a vedea solutia, un constructor ce instantiaza array-ul si o metoda computeSolution ce va calcula solutia efectiva. In aceasta functie am creat cate o copie locala a evenimentelor si a salilor, un arraylist a evenimentelor care pot sa ramana neprogramate si un array de string-uri in care voi pune pentru fiecare sala intervalele la care aceasta este ocupata (indexul ce parcurge acest array este corespondent cu indexul vectorului copyRooms, de exemplu intervalsRooms[index] corespunde salii ce se alfa la pozitia index). Am aplicat metoda greedy astfel incat algoritmul alege evenimentul care se termina cel mai repede. Pe masura ce asignez unui eveniment o sala, scad numarul de evenimente pana cand nu mai am evenimente disponibile. Parcurg apoi toate evenimentele si le compar timpul de sfarsit, iar index salveaza pozitia acestuia. Apoi pentru o sala verific pe rand cate o sala daca numarul de participanti este egal cu cel al capacitatii salii, iar daca este egal verific daca este libera in intervalul evenimentului folosind functia checkIfIntervalIsFree, iar daca este atunci adaug acel interval la sala respectiva. Daca am parcurs toate salile si variabila foundRoom este falsa, atunci adaug evenimentul in vectorul cu evenimente ce nu au putut fi asignate unei sali, si elimin evenimentul curent. La sfarsit adaug in solutie si evenimentele neasignate (daca este cazul).