1. Compulsory:
Am creat un proiect Maven si am actualizat fisierul pom.xml.
Am creat clasele Intersection si Street. Clasa Intersection are ca atribut un nume, 2 constructori, settere, gettere, metodele toString si equals. Clasa Street are ca atribute un nume, o lungime si un vector de marime 2 in care se afla capetele unei strazi, capetele fiind in cazul nostru 2 intersectii. Clasa mai contine 2 constructori, settere, gettere, toString si metoda compareTo folosita pentru a compara 2 strazi dupa nume. In clasa Main am creat intersectiile folosindu-ma de stream-uri, apoi am creat o lista streets de tip LinkedList in care am pus obiectele de tip street din exemplu. Am sortat lista de strazi in functie de lungimea acestora. Am creat o multime de tip HashSet initializata cu vectorul de intersectii creat cu un stream si apoi am parcurs multimea de intersectii si am verificat daca gasesc 2 intersectii care au acelasi nume si nu sunt referinte la acelasi obiect.

2. Homework: 
Am creat o clasa City care contine un map ce are ca si cheie o intersectie, si ca valoare o lista de strazi care contin unul din capete intersectia data ca si cheie, settere, gettere, toString si o metoda endsSum, care cauta in map capetele strazii si returneaza suma strazilor incidente in aceste noduri, minus 2, adica fara strada cautata. In main am creat un map care pentru fiecare intersectie cauta strazile incidente cu ea. Pentru generatorul de nume am adaugat ca dependinta in fisierul pom.xml libraria javafaker si am creat un obiect Faker, dupa care am parcurs strazile si intersectiile si am setat numele folosind faker.name().lastName(). Am creat un obiect City si folosind stream-uri am afisat strazile care au lungimea mai mare decat 1 si in capete sunt incidente cel putin alte 6 strazi (folosind functia endsSum). Pentru a gasi solutia problemei, am creat un graf in care am pus intersectiile ca noduri, si apoi am creat o multime addedStreets ca sa nu adaug de mai multe ori aceeasi muchie. Iterand prin strazi, daca strada nu se afla in aceasta multime atunci o adaug, creez o muchie ce are capetele strazii curente si ii setez costul, iar la sfarsit returnez graful creat. Solutia efectiva este gasita de metoda getSpanningTree() al obiectului spanningTree de tip PrimMinimumSpanningTree care ofera o implementare a algoritmului lui Prim.